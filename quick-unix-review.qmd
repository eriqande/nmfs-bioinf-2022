# Quick review of some essential Unix


- The bash shell is actually an interpreted programming language.
- It has variables, for loops, flow control, etc.
- Let's get familiar with this!


## Setting up our workspace

- I have prepared a repository with a few different example data files
that we be using.
- It also contains all these notes.
- I want everyone to download it to their home directory and then
`cd` into its `playground` directory, where we will be playing for the
next two days.

After logging onto SEDNA:
```{.sh filename="Paste this into your shell"}
cd ~
git clone https://github.com/eriqande/nmfs-bioinf-2022.git
cd nmfs-bioinf-2022/playground
```

- This is where our working directory will be for the next two days.
- Use the `tree` utility to see the files that we have to play with within
this playground:
```{.sh filename="Type this command at you prompt"}
tree
```

The `data` directory has a few things that we will be using for examples.

::: {.callout-note collapse=true}

## Unix commands we just saw:

- `cd`: change directories
- `git`: run git subcommands, like `clone` with this. In the above case it clones
the repository that is found at the GitHub URL.
- `tree`: Super cool "text-graphical" directory listing
- `less`: page view.  Great to pipe output into. (`SPACE-bar`, `b`, `q`)
    - `less -S`: option to not wrap lines.  (`left-arrow`, `right-arrow`)

:::

## A motivating example

- The `data/samtools_stats` directory has gzipped output from running the `samtools stats`
program on 30 different samples.
- This provides information about reads that have been mapped to a reference genome in a BAM file.

To see what those files look like:
```{.sh filename="Paste this into your terminal"}
zcat data/samtools_stats/s001_stats.tsv.gz | less
```

- Hit the SPACE-bar to go down, the `b` key to go back up
- Hit the `q` key to quit out of the `less` viewer.

To see it without lines wrapping all over the place try this:
```{.sh filename="Paste this into your terminal"}
zcat data/samtools_stats/s001_stats.tsv.gz | less
```

- Now you can use the left and right arrows to see different parts of lines
that are not wrapped on the screen.

::: {.callout-note collapse=true}

## Unix commands we just saw:

- `zcat`: decompress gzipped file to _stdout_.
- `less`: page view.  Great to pipe output into.
    - `less -S`: option to not wrap lines.

:::

### (One of) Our Missions...

It is pretty typical that Bioinformatic outputs will be spread as small bits of
information across multiple files.

One motivating example is summarizing the number of properly paired reads,
and the total number of bases mapped, in all 30 samples, _in a table_.

## The anatomy of a Unix command

Nearly every line in a bash script, or every line you type when banging away at the
Unix terminal is a command that has this structure:


`command` options _arguments_

- The `command` is the name of the command itself (like `cd` or `less`).
- The options are often given:
    - with a dash plus a single character, like `-l` or `-S` or `-a`, `-v`, `-z`.
    - In most commands that are part of Unix, these single options can be combined,
         so `-avz`, is the same as `-a -v -z`.
    - with two dashes and a word, like `--long` or `--version`
    - Sometimes options take arguments, like `--cores 20`, but sometimes, they stand alone.  
        - When they stand alone they are sometimes called _flags_.
- The _arguments_ are typically file or paths.


::: {.callout-tip}

## Self-study question

Identify the command, options, and arguments in:

```{.sh}
tree -d ..
```
:::

::: {.callout-tip collapse=true}

## Self-study answer

- `tree` is the command 
- `-d` is the option (print only directory names, not files)
- `..` is the argument (one directory level up)

:::


### What do all these options mean?

Everything you need to know about any Unix command will typically be found
with the `man` command.  For example:
```{.sh filename="type this at your terminal"}
man tree
```
- That gives you more information than you will ever want to know.
- It starts with a synopsis of all the options, etc.


## Streams and redirection

- When you've executed the unix commands above, they have typically responded
by writing text or data to the terminal screen.
- The command is actually writing to a _stream_ that is called `stdout`, which
is short for "standard output." 
- It turns out that, by default, the `stdout` stream gets written to the terminal.

Aha! But here is where it gets fun:

- You can _redirect_ the `stdout` stream to a file by using `>` or `>>` after the
command, options, and arguments.

For example:
```{.sh filename="Paste this into your terminal"}
mkdir outputs
tree -d .. > outputs/repo-tree.txt
```

Now, you can use the `less` viewer to see what got into the file `outputs/repo-tree.txt`:
```{.sh filename="Type this at the terminal"}
less outputs/repo-tree.txt
```

Aha! Instead of writing the output to the screen, it just puts it in the file
`less outputs/repo-tree.txt`, as we told it to.

::: {.callout-important}

## Danger!

If you redirect `stdout` into a file that already exists, the contents of that
file will get erased!!!

For example, if you now do:
```{.sh filename="Paste this into the shell"}
echo "New content coming through..." > outputs/repo-tree.txt
```
Then you will no longer have the output of the `tree` command
in the file `outputs/repo-tree.txt`.  Check it out with the `less` command.
:::

If you want to merely _append_ `stdout` to an existing file, you can use
`>>`.  For example:
```{.sh filename="Paste this into your terminal"}
echo "Add this line" >> outputs/repo-tree.txt
echo "And then add another line" >> outputs/repo-tree.txt
```


## Pipes: redirecting into another Unix command

As we have said, many Unix utilities take files as their arguments, and they
operate on the contents of that file.  They can also receive input from _streams_,
and almost all Unix utilities are set up to accept input from the stream called
`stdin`, which is short for _standard input_.

- The most important way to pass the `stdin` stream to a Unix command is by
_piping_ the `stdout` from one command in as the `stdin` to the next command.

- This uses the `|` which is called the "pipe".  

We have already used the pipe when we did:
```{.sh}
zcat data/samtools_stats/s001_stats.tsv.gz | less
```