# Shell Programming

- The bash shell is actually an interpreted programming language.
- It has variables, `for` loops, flow control, etc.
- Here, we survey just a few of the most useful constructs that let
us to a lot of things, and particularly allow us to tackle
repetitive tasks with grace.



## Variables

The bash shell can store strings into variables.  These variables can
be accessed later.

### Assigning variable values

- bash is remarkably picky about how to assign a value to a variable.
- Use the equals sign _with no spaces around it!_

Here, we can assign a value to a variable called PHONE:
```{.sh filename="Paste this into your shell"}
PHONE=974-222-4444
```

In this case the digits and dashes `974-222-4444` are treated as just
a string of characters and assigned to the variable `PHONE`.

### Accessing variable values

- The process of accessing the values stored in the variable is called
"variable substitution.
- It means: "Substitute the value for the variable where it appears on the command line."
- In many programming languages, you can just write a variable's name and know that
its value will be accessed, like in R:
```{.r}
Variable <- 16
sqrt(Variable)
```
- **However, in bash, variable substitution is achieved by prepending `$` to the variable's name.**

Witness:
```{.sh filename="Paste this into your shell"}
echo The value of PHONE is: $PHONE
```

Cool!

- Remember: if you make a substitution to the menu at a fancy restaurant, it is going to cost you
some dollars.  Same way when you make a variable substitution in bash: it costs you a dollar sign
and you have to pay up front.


### Valid bash variable names

The bash shell demands that the names of variables:

- Start with `_` (an underscore) or a letter
- Then include only `_`, letters, or numbers

```{.sh}
# good variable names
MY_JOBS
_NOW
STRING
i
i_2
i2

# cannot be variable names
1_node
4THIS
BIG-VAR
file-name
Sh**t!
```

## Strings with spaces, etc:  Quoting.

- If you want to assign a string to a variable that has spaces in it
you can quote the string, which holds it together as one "unit."

::: {.callout-warning collapse=true}

## Bonus Info:

When the bash shell is interpreting a line of input, it breaks
it into chunks called _tokens_ which are separated by white space
(spaces and TABS).  If you wrap a series of words in quotation
marks, it turns them all into a single token.
:::

For example:
```{.sh filename="Paste this into your shell"}
Mandela_Quote="The greatest glory in living lies not in never falling, but in rising every time we fall."
echo $Mandela_Quote
```


## Variable substitution and `"` vs `'`

We have two types of quotes:

- single quotes, like `'`
- double quotes, like `"`

They both chunk their contents into a single unit, but
they behave very differently _with respect to variable
substition_.

- Single Quotes: surly and strict, you can't substitute 
values for variables inside of these.

Example:
```{.sh filename="Paste this into your shell"}
DESSERT="apple pie"
echo 'Dessert tonight is $DESSERT'
```


- Double Quotes: soft and friendly, you CAN substitute 
values for variables inside of these.

Example:
```{.sh filename="Paste this into your shell"}
DESSERT="apple pie"
echo "Dessert tonight is $DESSERT"
```

::: {.callout-tip}

## Self study

Define the shell variables `NAME`, `FOOD`, and `ACTIVITY` so that
when you run the following command, it makes sense:
```{.sh filename="After definining the three variables, run this command"}
echo "My name is $NAME. I like to eat $FOOD, and I enjoy $ACTIVITY." 
```
:::

::: {.callout-tip collapse=true}

## Self Study answer

For my case, I could put:
```{.sh}
NAME=Eric
FOOD="steamed broccoli"
ACTIVITY="inline skating long distances"
```
:::


## Variables are not just to be echoed!

Invariably, when learning how to use shell variables, all the
examples have you using `echo` to print the value of the
variable.  How boring and misleading.

It is important to understand that after a value gets substituted
onto the command line, the shell goes right ahead and evaluates
the resulting command line.

So, you can record shell variables that are command lines that
do something, themselves, once they are run as a command line.

For example, here we make a variable whose value is the command
to decompress a file to stdout:
```{.sh filename="Paste this into your shell"}
MyComm="gzip -cd data/samtools_stats/s001_stats.tsv.gz"
```
And now if you just substitute that variable onto the command line
```{.sh filename="Type this at the command line"}
$MyComm
```
the uncompressed contents of the file `data/samtools_stats/s001_stats.tsv.gz` go
zooming by on your screen.

### Some subtlety about evaluation of substituted values

If the value of the variable that is being evaluated includes _pipes_, 
_redirections_, or variable assignment statements, then if you just subtituting
it into the command line, it won't properly be evaluated as a command line
in full.  For example, if `MyComm` was trying to decompress the file and
pipe it to `less`, it doesn't work as expected:
```{.sh filename="Paste this into your shell"}
MyComm="gzip -cd data/samtools_stats/s001_stats.tsv.gz | less -S"
```
And now if you just substitute that variable onto the command line
the shell gets confused, because it doesn't recognize the pipe as a pipe!
```{.sh filename="Type this at the command line"}
$MyComm
```

However, you can use the `eval` keyword before `$MyComm` to ensure
that the shell recognizes that you intend for it to evaluate pipes,
redirects, shell variable assignment, etc. in the substituted variable
value as it normally would:
```{.sh filename="Type this at the command line"}
eval $MyComm
```

We will end up using this later.


## Multiple commands on one line with `;`

- You can put a `;` after a command, and it will behave like a line ending---the
shell will run that command, and then go to the next.

Example:
```{.sh filname="Paste this into your terminal"}
echo "Let us do this command and 2 others"; echo "here is number 2"; echo "and the third"
```

This comes in handy.


## Repetition

Let's face it, bioinformatics, or any sort of data analysis or
processing often involves doing the _same_ thing to a number of
_different_ inputs.

Most unix utilities and designed so that if you give it multiple inputs
it will do the same thing to each and report the results in a way that is
easy to understand.

For example, to see how many lines, words, and characters are in each Quarto
(the successor to RMarkdown) document that I used to make this website, we
can use `wc` on all the files with a `.qmd` extension that are one directory
level above where we are currently:
```{.sh filename="Paste this into your shell"}
wc ../*.qmd
```

This is nice.

## For loops

Sometimes, however, we have more complex operations to do, so we can't
just provide multiple files to a single Unix utility.

For example, let's say we want to know how many lines are in each of the
samtools stats files in the `data/samtools_stats` directory.  We can't use
`wc` directly, because these files are gzipped, and the result we get won't be
equal to the number of lines, words, and characters in each file.

For repetition in these cases, bash has a `for` loop.  Its syntax looks like this:
```{.sh}
for VAR in thing1 thing2 ... thingN; do
  some command where $VAR substitutes each of the N things in turn
done
```

The important "structural" parts of that are:

- the `for`
- the `in`
- the semicolon after all the things
- the `do`
- the `done`

Here is an example:
```{.sh filename="Paste this into your terminal"}
for LIKE in trout butterflies "blue skies" "mathematical notation"; do 
  echo "I like $LIKE."
done
```


Note that this is written over multiple lines, but we can substitute
`;` for the ends of statements and put it all on one line. (Useful if we are
just hacking away on the command line...)
```{.sh filename="This does the same as the above one"}
for LIKE in trout butterflies "blue skies" "mathematical notation"; do echo "I like $LIKE."; done
```

Note! Don't put a semicolon after `do`.

::: {.callout-tip}

## Self study

We want to give the number of text lines, words, and characters from all
the samtools_stats files.  

**Prep:** Here is a command that prints the name of each
file. 
```{.sh filename="Paste this into the terminal"}
for FILE in data/samtools_stats/*.gz; do echo $FILE; done
```

**Task:** I have added the `-n` option to the `echo` command which
makes it not print a line ending. Your
task is to replace YOUR_STUFF_HERE with an appropriate shell command
to decompress each file and then print the number of lines, words, and characters
in it:
```{.sh filename="Paste this, edit YOUR_STUFF_HERE, and run it"}
for FILE in data/samtools_stats/*.gz; do echo -n $FILE; YOUR_STUFF_HERE; done
```

:::

::: {.callout-tip collapse=true}

## Self Study answer

Your edited command line should look like this:
```{.sh}
for FILE in data/samtools_stats/*.gz; do echo -n $FILE; gzip -cd $FILE | wc; done
```

:::


## Redirect `stdout` from the `done`

Here is something that is not always obvious: you can redirect or
pipe the `stdout` of the whole for loop by using `>` or `|` immediately
after the `done` keyword.

Using the example from the self study above:
```{.sh filename="Paste this into your terminal"}
for FILE in data/samtools_stats/*.gz; do 
  echo -n $FILE; gzip -cd $FILE | wc; 
done > word_counts.txt
```

Now look at what is in `word_counts.txt`.

## A few useful topics, rapidly

### basename

- If you have a path name to a file `this_dir/that_dir/my_file3.txt`, but you
want to have the string for just the file name, `my_file3.txt`, you can use the
`basename` command: 
```{.sh filename="Try these"}
basename this_dir/that_dir/my_file3.txt
basename ~/Documents/git-repos/CKMRpop/R/plot_conn_comps.R
```

### Capture `stdout` into a token to put on the command line



## Fancier variable substitution

### Safer: ${j}

### Variable mangling

The one I always use: `${j/x/}`

## Capture `stdout` and put it on the command line: `$(...)`

## Multiple lines separated by `;` or `&&`

## `&` at the end of a line---rarely used in a SLURM environment

## Grouping multiple commands with `(...)`